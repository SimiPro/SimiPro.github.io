<!DOCTYPE html>
<html>
<head>

    <!-- Basic Page Needs
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta charset="utf-8">
    <title>Simi's Page</title>
    <meta name="description" content="">
    <meta name="author" content="Simon Huber">

    <!-- Mobile Specific Metas
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- FONT
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

    <!-- CSS
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/skeleton.css">
    <link rel="stylesheet" href="../css/custom.css">
    <link href="../css/prism.css" rel="stylesheet" />
    <!-- Favicon
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link rel="icon" type="image/png" href="../images/favicon.png">
    <style>
        code {
            font-family: Consolas,"courier new";
            background-color: #f1f1f1;
            padding: 2px;
            font-size: 105%;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Shortest Distance Stuff</h1>
    <h2>First lets constraint a point to a segment</h2>
    <p>
        Square root of two:
        <math>
            <msqrt>
                <mn>2</mn>
            </msqrt>
        </math>
    </p>

    <pre>

      <code class="language-js">
function clamp01(t) {
    if (t > 1)
        return 1
    if (t < 0)
        return 0;
    return t;
}


function projectToSegment(p, a, b) {
    let ab = M.sub(b, a);
    let t = 1;
    if (M.dot(ab, ab) >= 1e-5) { // check if parallel
        t = M.dot(M.sub(p, a), ab);
        t = t / M.dot(ab, ab);
        t = clamp01(t);
    }
    return M.add(a, M.smul(t, ab));
}
      </code>
    </pre>    <div class="row">
        <div id="pointToSegment" class="ten column" style="height: 400px"></div>
    </div>

    <h2>Now lets use this to calculate segment to segment distance</h2>
    <pre>
      <code class="language-js">
function SegSegShortestDist(p1, p2, p3, p4) {
    // 2. create a plane with the normal being the direction of the segment and the
    //    starting point being the start of the segment
    let nPlane = M.sub(p2, p1);
    let pPlane = p1;

    // 3. project the other segment onto this plane
    //    now we reduced the problem to a simple point to segment distance problem
    let p3_ = projectToPlane(nPlane, pPlane, p3);
    let p4_ = projectToPlane(nPlane, pPlane, p4);

    // 4. we calculate that distance
    // now p1 and the line segment p4_, p3_ lie in the same plane
    // which means all we have to do is project the point p1 onto the line segment e34_
    // this gives us lambda
    let e34_ = M.sub(p4_, p3_);
    let lambda = 0.5;
    if (e34_.dot(e34_) > 1e-7) { // check if not parallel
        lambda = M.sub(p1, p3_).dot(e34_) / e34_.dot(e34_);
    }

    // the point calculated is now on the "line" if there was any
    lambda = clamp01(lambda);
    let p34_line = M.add(p3, M.smul(lambda, M.sub(p4, p3)));

    // so we project it normally back to the line segment
    // to be really accurate we have to project the point first on the segment 1,2
    let p12_seg = projectToSegment(p34_line, p1, p2);

    // and now also this point onto the segment 3,4
    // and now also project this normally to the other line segment
    let p34_seg = projectToSegment(p12_seg, p3, p4);
    return [p12_seg, p34_seg]
}
        </code>
    </pre>
    <div class="row">
        <div id="SegVsSeg" class="ten column" style="height: 400px"></div>
    </div>
    <h2>Point To Rectangle</h2>

    <pre>
              <code class="language-js">


export function pointToRectangle(p0, p1, p2, q) {
    const p = p0;

    // first calculate the plane directions
    let u1 = sub(p1, p0);
    let u2_ = sub(p2, p0);

    // calculate the dimensions
    let ext1 = u1.length();
    let ext2 = u2_.length();

    u1.normalize();
    u2_.normalize();

    // calculate the normal
    let nNormal = cross(u1, u2_);
    let u2 = cross(u1, nNormal);

    // check if we have to turn u2 because it could point into the wrong direction
    if (sub(add(p, u2), p2).length() > sub(add(p, u2.clone().negate()), p2).length()) {
        u2.negate();
    }

    // this is the "meat" on how to project the points onto the rectangle
    // the dot product tells us where the position is relative to the plane directions
    let diff = sub(q, p);
    let s = clamp(u1.dot(diff), 0, ext1);
    let t = clamp(u2.dot(diff), 0, ext2);

    // r(s,t) = p + s*u1 + t*u2
    return add(add(p, smul(s, u1)), smul(t, u2));
}
        </code>
    </pre>
    <div class="row">
        <div id="PointToRectangle" class="ten column" style="height: 400px"></div>
    </div>
    <h2>Segment To Rectangle</h2>

    <div class="row">
        <div id="SegToRect" class="ten column" style="height: 400px"></div>
    </div>
    <h2>Segment To Rectangle Correct</h2>
    <pre>
        <code class="language-js">

export function shortestDistanceRectangleSegment(p0, p1, p2, s1, s2) {
    // project segment to rectangle
    let s1_proj = pointToRectangle(p0, p1, p2, s1);
    let s2_proj = pointToRectangle(p0, p1, p2, s2);

    // shortest distance between this segment & rectngle
    let res = segSegShortestDist(s1, s2, s1_proj, s2_proj);
    let min_dist = sub(res[0], res[1]).length();
    let min_p1 = res[0];
    let min_p2 = res[1];

    let R = getRectanglePoints(p0, p1, p2);
    let r1 = R[0], r2 = R[1], r3 = R[2], r4 = R[3];

    // but now check all the other segments as well
    res = segSegShortestDist(s1, s2, r1, r2);
    let dist = sub(res[0], res[1]);
    if (dist < min_dist) {
        min_dist = dist;
        min_p1 = res[0];
        min_p2 = res[1];
    }

    res = segSegShortestDist(s1, s2, r2, r3);
    dist = sub(res[0], res[1]);
    if (dist < min_dist) {
        min_dist = dist;
        min_p1 = res[0];
        min_p2 = res[1];
    }

    res = segSegShortestDist(s1, s2, r3, r4);
    dist = sub(res[0], res[1]);
    if (dist < min_dist) {
        min_dist = dist;
        min_p1 = res[0];
        min_p2 = res[1];
    }

    res = segSegShortestDist(s1, s2, r4, r1);
    dist = sub(res[0], res[1]);
    if (dist < min_dist) {
        min_dist = dist;
        min_p1 = res[0];
        min_p2 = res[1];
    }

    return [min_p1, min_p2, min_dist];
}

        </code>
    </pre>
    <div class="row">
        <div id="SegToRectCorrect" class="ten column" style="height: 400px"></div>
    </div>
    <h2>Segment To Box</h2>
    <pre>
        <code class="language-js">
// 1. translate world point to rectangle local points
let s1 = worldToLocal(p, R, s1_);
let s2 = worldToLocal(p, R, s2_);

// 2. create orthogonal vectors that make up the box
// we calculate shortest distance to
// dims = [width, height, depth] => x, y, z
let u1 = smul(dims[0],  new THREE.Vector3(1, 0 , 0));
let u2 = smul(dims[1], new THREE.Vector3(0, 1 , 0));
let u3 = smul(dims[2], new THREE.Vector3(0, 0 , 1));

// 3. create all the planes of the box
let p1 = new THREE.Vector3( - dims[0]/2., - dims[1]/2., - dims[2]/2);
let p2 = add(p1, u2);
let p3 = add(add(p1, u1), u2);
let p4 = add(p1, u1);
let p5 = add(p1, u3);
let p6 = add(p2, u3);
let p7 = add(p3, u3);
let p8 = add(p4, u3);

let plane1 = [p1, p2, p3, p4];
let plane2 = [p1, p4, p8, p5];
let plane3 = [p5, p6, p7, p8];
let plane4 = [p8, p7, p3, p4];
let plane5 = [p5, p6, p2, p1];
let plane6 = [p6, p2, p3, p7];
let planes = [plane1, plane2, plane3, plane4, plane5, plane6];

// 4. calculate the distances to all the planes (reduction to segment to plane distance)
//      we could be more clever here to only calculate to the necessary planes.
let min_dist = 1000000;
let p1_min;
let p2_min;
for (let plane of planes) {
        let res = shortestDistanceRectangleSegment_rOrtho(plane[0], plane[1], plane[2], plane[3], s1, s2);
        if (res[2] < min_dist) {
            min_dist = res[2];
            p1_min = res[0];
            p2_min = res[1];
        }
}

// 5. translate point back to world
p1_min = localToWorld(p, R, p1_min);
p2_min = localToWorld(p, R, p2_min);

return [p1_min, p2_min, min_dist];
        </code>
    </pre>
    <div class="row">
        <div id="SegVsBoxGui"></div>
        <div id="SegVsBox" class="ten column" style="height: 400px"></div>
    </div>

</div> <!-- container -->

<script  type="module" src="js/pointToSegment.js"></script>
<script  type="module" src="js/segVsSeg.js"></script>
<script  type="module" src="js/pointToRectangle.js"></script>
<script  type="module" src="js/segVsRectangle.js"></script>
<script  type="module" src="js/segVsRectangle_correct.js"></script>
<script  type="module" src="js/segVsBox.js"></script>
<script src="../build/prism.js"></script>



</body>
</html>